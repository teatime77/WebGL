<html>
<head>
<title>Geodesic grid
</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-Control" content="no-cache">

<script type="text/javascript" src="../../js/Sys.js"></script>
<script type="text/javascript" src="../../js/gpgpu.js"></script>
<script type="text/javascript" src="../../js/ndarray.js"></script>
<script type="text/javascript" src="../../js/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="../../js/GeodesicGrid.js"></script>

<script type="text/javascript">
class MyDraw {
    constructor() {
        this.img = new Image();

        this.img.onload = function () {
            var canvas = document.getElementById("webgl-canvas");
            this.MyWebGL = CreateWebGLLib(canvas);
            this.MyWebGL.Draw3D(this);
        }.bind(this);

        this.img.src = "world.topo.bathy.200408.2048x2048.png";
    }

    onDraw() {
        if (!this.param) {
            var vertex_shader = `#version 300 es
                precision highp float;
                precision highp int;

                const vec3 uAmbientColor = vec3(0.2, 0.2, 0.2);
                const vec3 uLightingDirection =  normalize( vec3(0.25, 0.25, 1) );
                const vec3 uDirectionalColor = vec3(0.8, 0.8, 0.8);

                // 位置
                in vec3 aVertexPosition;

                // 法線
                in vec3 aVertexNormal;

                // テクスチャ座標
                in vec2 aTextureCoord;

                uniform mat4 uPMVMatrix;
                uniform mat3 uNMatrix;

                out vec3 vLightWeighting;

	            out vec2 uv0;
	            out vec2 uv1;
            
                void main(void) {
                    gl_Position = uPMVMatrix * vec4(aVertexPosition, 1.0);

                    vec3 transformedNormal = uNMatrix * aVertexNormal;
                    float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
                    vLightWeighting = uAmbientColor +uDirectionalColor * directionalLightWeighting;

		            uv0 = fract( aTextureCoord.st );
		            uv1 = fract( aTextureCoord.st + vec2(0.5,0.5) ) - vec2(0.5,0.5);
                }
            `;

            var ret = makeEarthBuffers();

            this.param = {
                id: "Earth",
                vertexShader: vertex_shader,
                fragmentShader: this.MyWebGL.defaultFragmentShader()
                ,
                args: {
                    "aVertexPosition": ret.vertex_array,
                    "aVertexNormal": ret.normal_array,
                    "aTextureCoord": ret.texture_array,
                    "TextureImage": this.img,
                }
                ,
                VertexIndexBuffer: ret.idx_array
            };
        }

        return this.param;
    }
}
</script>
</head>
<body onload="new MyDraw()">
    <canvas id="webgl-canvas" style="border: none;" width="500" height="500"></canvas>
</body>
</html>
