<html>
<head>
<title>Geodesic grid
</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-Control" content="no-cache">

<script type="text/javascript" src="../../js/Sys.js"></script>
<script type="text/javascript" src="../../js/gpgpu.js"></script>
<script type="text/javascript" src="../../js/ndarray.js"></script>
<script type="text/javascript" src="../../js/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="../../js/GeodesicGrid.js"></script>

<script type="text/javascript">

function bodyOnLoad() {
    var vertex_shader = `#version 300 es
        precision highp float;
        precision highp int;

        const vec3 uAmbientColor = vec3(0.2, 0.2, 0.2);
        const vec3 uLightingDirection =  normalize( vec3(0.25, 0.25, 1) );
        const vec3 uDirectionalColor = vec3(0.8, 0.8, 0.8);

        // 位置
        in vec3 aVertexPosition;

        // 法線
        in vec3 aVertexNormal;

        // テクスチャ座標
        in vec2 aTextureCoord;

        uniform mat4 uPMVMatrix;
        uniform mat3 uNMatrix;

        out vec3 vLightWeighting;

	    out vec2 uv0;
	    out vec2 uv1;

        void main(void) {
            gl_Position = uPMVMatrix * vec4(aVertexPosition, 1.0);

            vec3 transformedNormal = uNMatrix * aVertexNormal;
            float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
            vLightWeighting = uAmbientColor +uDirectionalColor * directionalLightWeighting;

		    uv0 = fract( aTextureCoord.st );
		    uv1 = fract( aTextureCoord.st + vec2(0.5,0.5) ) - vec2(0.5,0.5);
        }
    `;

    var fragment_shader = `#version 300 es
        precision highp float;
        precision highp int;

        in vec3 vLightWeighting;
	    in vec2 uv0;
	    in vec2 uv1;

        uniform sampler2D TextureImage;

        out vec4 color;

        void main(void) {
            vec2 uvT;

		    uvT.x = ( fwidth( uv0.x ) < fwidth( uv1.x )-0.001 ) ? uv0.x : uv1.x ;
		    uvT.y = ( fwidth( uv0.y ) < fwidth( uv1.y )-0.001 ) ? uv0.y : uv1.y ;

            vec4 textureColor = texture(TextureImage, uvT);

            color = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
        }
    `;

    var img;
    var xRot = 0;
    var yRot = 0;
    var z = -5.0;

    var lastMouseX = null;
    var lastMouseY = null;

    var param;

    var MyWebGL;

    function drawScene() {
        if (!param) {

            var ret = makeEarthBuffers();

            param = {
                id: "Earth",
                vertexShader: vertex_shader,
                fragmentShader: fragment_shader
                ,
                args: {
                    "aVertexPosition": ret.vertex_array,
                    "aVertexNormal": ret.normal_array,
                    "aTextureCoord": ret.texture_array,
                    "TextureImage": img,
                }
                ,
                VertexIndexBuffer: ret.idx_array
            };
        }

        var pMatrix = mat4.create();
        mat4.perspective(45, MyWebGL.canvas.width / MyWebGL.canvas.height, 0.1, 100.0, pMatrix);

        var mvMatrix = mat4.create();
        mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, [0.0, 0.0, z]);

        mat4.rotate(mvMatrix, xRot, [1, 0, 0]);
        mat4.rotate(mvMatrix, yRot, [0, 1, 0]);

        var pmvMatrix = mat4.create();
        mat4.multiply(pMatrix, mvMatrix, pmvMatrix);

        var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);

        param.args["uPMVMatrix"] = pmvMatrix;
        param.args["uNMatrix"] = normalMatrix;

        MyWebGL.compute(param);

        window.requestAnimationFrame(drawScene);
    }

    var canvas = document.getElementById("webgl-canvas");
    MyWebGL = CreateWebGLLib(canvas);

    img         = new Image();
    img.onload  = drawScene;
    img.src     = "world.topo.bathy.200408.2048x2048.png";

    canvas.addEventListener('mousemove', function (event) {
        var newX = event.clientX;
        var newY = event.clientY;

        if (event.buttons != 0 && lastMouseX != null) {

            xRot += (newY - lastMouseY) / 300;
            yRot += (newX - lastMouseX) / 300;
        }

        lastMouseX = newX
        lastMouseY = newY;
    });

    canvas.addEventListener("wheel", function (e) {
        z += 0.002 * e.wheelDelta;

        // ホイール操作によるスクロールを無効化する
        e.preventDefault();
    });
}
</script>
</head>
<body onload="bodyOnLoad()">
    <canvas id="webgl-canvas" style="border: none;" width="500" height="500"></canvas>
</body>
</html>
